# Refactoring the Lexer and the Parser
This document will outline the changes made to the lexer and the parser and the reasons for them.

## Current Lexer and Parser
The current lexer uses an `enum` to represent all the information in a struct, which leads to some
problems when trying to match token types.

Current representation (not all variants listed):

```rust
enum Token {
    Dot(u32, u32),
    Semicolon(u32, u32),
    Identifier(String, u32, u32),
    Integer(i64, u32, u32),
}
```

In this representation, all the information is stored inside the `enum`, so if we ever need to match
on it, we need to take care of the fields. This has led to some messy situations in the parser, the biggest
one currently is looping until a certain `enum` variant is encountered. In order to check that now,
`std::mem::discriminant()` must be used, which gets messy to use after a while.

## New Lexer and Parser
The new lexer and parser will use 2 different kinds of `structs` for tokens, with each token type
being in a separate `enum`:

### Lexer Types
* `struct LexerToken`: This will contain all the token data generated by the lexer. It contains information
such as position numbers, token type, and an optional value
* `enum LexerTokenType`: This will contain all the different possible token types that can be created
including keywords, parentheses, periods, identifiers, numbers, etc
by the lexer

### Parser Types
* `struct AstToken`: This will contain all the token data generated by the parser. It contains almost the
same data as `LexerToken`.
* `enum AstTokenType`: This will contain all the different token types created by the parser; it's a
subset of `LexerTokenType` because the parser discards stuff like parentheses. This is to simplify the
data structure so less conditions need to be taken of down the line.

### Shared Types
* `enum TokenValue`: This will contain the different possible values that can be stored in tokens. There
are 4 different kinds of values: integers, floats, strings, and identifiers. Each of them has a value associated
with it. Both `LexerToken` and `AstToken` use this.

### Benefits of New Design
With this new design, all the different data types are separate, and the actual data is stored separately from
the token type, so it's easier to manipulate tokens. This will help clean up the codebase by reducing the usage
of `std::mem::discriminant()`, and it will make it easier to match on token types. In short, it will allow us
to make it easier to manipulate tokens.

* Simpler loop conditions
* Easier operations with macros (no need to worry about values in token types)
* Cleaner code in general because not everything is in one place

### Unresolved Questions
None.
